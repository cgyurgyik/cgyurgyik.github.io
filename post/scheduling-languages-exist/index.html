<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="author" content="Christophe Gyurgyik">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Christophe Gyurgyik | PhD Candidate, Stanford University</title>

  <link rel="icon" href="/flower.svg" type="image/svg+xml">

  <link rel="stylesheet" href=https://cgyurgyik.github.io/css/normalize.css>
  <link rel="stylesheet" href=https://cgyurgyik.github.io/css/default.css>
  <link rel="stylesheet" href="https://pro.fontawesome.com/releases/v5.10.0/css/all.css"
    integrity="sha384-AYmEC3Yw5cVb3ZcuHtOA93w35dYTsvhLPVnYs9eStHfGJvOvKxVfELGroGkvsg+p" crossorigin="anonymous" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.9.1/css/academicons.min.css"
    integrity="sha512-b1ASx0WHgVFL5ZQhTgiPWX+68KjS38Jk87jg7pe+qC7q9YkEtFq0z7xCglv7qGIs/68d3mAp+StfC8WKC5SSAg=="
    crossorigin="anonymous" />

  
  <link rel="alternate" type="application/rss+xml" title="RSS" href="https://cgyurgyik.github.io/ post/atom.xml">
  

  <script type="text/x-mathjax-config">
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ["\\(", "\\)"]],
        displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
        processEscapes: true,
      }
    }
  </script>

  <script type="text/javascript" id="MathJax-script" defer
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
    </script>

</head>

<body>
  <header>
    <h1 class="name"><a class="unstyled-link" href="/">Christophe Gyurgyik</a></h1>
    <nav>
      <a class="unstyled-link nav-item" href="/#publications">Publications</a>
      <a class="unstyled-link nav-item" href="/#posts">Posts</a>
      <a class="unstyled-link nav-item" href="/files/resume.pdf">CV</a>
      <a class="unstyled-link nav-item" href="/#adventures">Adventures</a>
    </nav>
  </header>
  <section class="section">
    <div class="container">
      
<div class="post-header">
<h1 class="title">
  Why scheduling languages exist
</h1>
<div class="date">
What Hoare wants and Rice forbids
</div>
<p class="date">December 23, 2025</p>
</div>

<div class="post">
<p>C.A.R. Hoare’s work <a rel="noopener nofollow noreferrer external" target="_blank" href="https://dl.acm.org/doi/10.5555/63445.C1104369">“Recursive data structures”</a> motivates a simple rule that good language design should abide by:</p>
<blockquote>
<p>(1) Implementation details that don’t affect program correctness should be syntactically <em>inexpressible</em>.</p>
</blockquote>
<p>Codd’s <a rel="noopener nofollow noreferrer external" target="_blank" href="https://www.seas.upenn.edu/~zives/03f/cis550/codd.pdf">relational model</a> attempts to realize this: you declare <em>what</em> you want and the implementation is determined by the query optimizer. For example,</p>
<pre><code data-lang="sql">SELECT age FROM users WHERE age &gt; 21
</code></pre>
<p>The declarative language specifies nothing about index usage, join order, or memory allocation. In practice, relational database programmers still reason about implementation details, shaping queries to optimize well. Most programming languages abandon (1) entirely, giving us:</p>
<blockquote>
<p>(2) Implementation details that don’t affect program correctness are syntactically <em>expressible</em>.</p>
</blockquote>
<p>Imperative languages like C are the obvious case, but even <a rel="noopener nofollow noreferrer external" target="_blank" href="https://dl.acm.org/doi/10.5555/645420.652528">Haskell qualifies</a>, where you make explicit decisions about memory representation:</p>
<pre><code data-lang="haskell">-- boxed (heap-allocated, thunk-able)
foo :: Int -&gt; Int
foo x = x + 1
<p>– unboxed (raw machine integer)
foo :: Int# -&gt; Int#
foo x = x +# 1#
</code></pre></p>
<p>Both snippets add <code>1</code> to the variable <code>x</code> with different data layouts. The choices are semantically invisible<sup class="footnote-reference"><a href="#1">1</a></sup> but syntactically different, and the latter exists solely for performance reasons. Scheduling languages like <a rel="noopener nofollow noreferrer external" target="_blank" href="https://dl.acm.org/doi/10.1145/2491956.2462176">Halide</a> and <a rel="noopener nofollow noreferrer external" target="_blank" href="https://dl.acm.org/doi/10.1145/3133901">TACO</a> take a different path:</p>
<blockquote>
<p>(3) Implementation details that don’t affect program correctness are confined to a separate language.</p>
</blockquote>
<p>In Halide, you write the algorithm once as a pure functional description, and then separately write a <em>schedule</em> specifying how the program should run. The schedule does not change the program semantics, only the execution strategy. This separation is enforced syntactically.</p>
<pre><code data-lang="cpp">// algorithm
f(x) = a(x) * b(x);
<p>// schedule
f.parallel(x);
</code></pre></p>
<p>The algorithm <code>f</code> is a simple element wise multiplication of two dense arrays <code>a</code> and <code>b</code>, and the schedule specifies that <code>f</code> should be run in parallel for all <code>x</code>.</p>
<p>Why not just achieve (1) with a sufficiently clever compiler? Because determining which details “don’t affect correctness” requires deciding program equivalence (<a rel="noopener nofollow noreferrer external" target="_blank" href="https://en.wikipedia.org/wiki/Rice%27s_theorem">Rice’s theorem</a> forbids this). Languages abiding to (3) sidestep the problem by narrowing the domain to something tractable. Further, (3) doesn’t require the compiler to discover all semantics-preserving transformations<sup class="footnote-reference"><a href="#2">2</a></sup>, they provide a language for the programmer to implement them, while <a rel="noopener nofollow noreferrer external" target="_blank" href="https://dl.acm.org/doi/10.1145/3519939.3523446">guaranteeing</a> that only semantics-preserving transformations are expressible.</p>
<p>So, why does (3) exist? (1) provides clarity but surrenders performance control, and (2) provides control at the cost of entanglement. Programmers in performance-critical domains want both semantic clarity and performance control. Scheduling languages deliver: reason about correctness in one language, optimize in another. This separation of concerns is <em>one</em> motivation for scheduling languages. There’s more to say (e.g., tractable search space, encapsulation benefits, ergonomic costs), but that’s for another post.</p>
<p style="font-size:10px"><b>Thank you to Rohan Yadav and AJ Root for their valuable feedback.</b></p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>This is not true in general, the domain of unboxed types has no bottom element which just means they cannot be lazily evaluated. However, the point remains.</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>Usually, scheduling languages also involve a compiler to realize some of the more “trivially” discoverable optimizations, e.g., constant folding or dead code elimination.</p>
</div>

</div>


    </div>
  </section>

  <footer>
    &copy;&nbsp;2025 Christophe Gyurgyik &middot; Built using <a href="https://www.getzola.org/">Zola</a> &middot;
    Adapted from <a href="https://www.rachitnigam.com/">Rachit Nigam</a>
  </footer>

</body>

</html>