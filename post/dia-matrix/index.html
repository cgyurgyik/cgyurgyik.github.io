<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="author" content="Christophe Gyurgyik">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Christophe Gyurgyik | PhD Student, Stanford University</title>

  <link rel="icon" href="/flower.svg" type="image/svg+xml">

  <link rel="stylesheet" href=https://cgyurgyik.github.io/css/normalize.css>
  <link rel="stylesheet" href=https://cgyurgyik.github.io/css/default.css>
  <link rel="stylesheet" href="https://pro.fontawesome.com/releases/v5.10.0/css/all.css" integrity="sha384-AYmEC3Yw5cVb3ZcuHtOA93w35dYTsvhLPVnYs9eStHfGJvOvKxVfELGroGkvsg+p" crossorigin="anonymous"/>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.9.1/css/academicons.min.css" integrity="sha512-b1ASx0WHgVFL5ZQhTgiPWX+68KjS38Jk87jg7pe+qC7q9YkEtFq0z7xCglv7qGIs/68d3mAp+StfC8WKC5SSAg==" crossorigin="anonymous"/>

  
  <link rel="alternate" type="application/rss+xml" title="RSS" href="https://cgyurgyik.github.io/post/atom.xml">
  

  <script type="text/x-mathjax-config">
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$', '$$'], ['\\[', '\\]']]
      }
    };
  </script>
  
  <script type="text/javascript" id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>
  
</head>

<body>
  <header>
    <h1 class="name"><a class="unstyled-link" href="/">Christophe Gyurgyik</a></h1>
    <nav>
      <a class="unstyled-link nav-item" href="/#publications">Publications</a>
      <a class="unstyled-link nav-item" href="/#posts">Posts</a>
      <a class="unstyled-link nav-item" href="/files/resume.pdf">CV</a>
    </nav>
  </header>
  <section class="section">
    <div class="container">
      
<div class="post-header">
<h1 class="title">
  A (slight) Improvement to Compressed Diagonal Matrix
</h1>
<div class="date">
less storage ⇒ better format
</div>
<p class="date">June 24, 2024</p>
</div>

<div class="post">
<p>Let’s say we want to compress a sparse diagonal (or symmetric matrix).
Here’s how <a rel="noopener nofollow noreferrer" target="_blank" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.dia_matrix.html">scipy.sparse</a> (and <a rel="noopener nofollow noreferrer" target="_blank" href="https://www.ibm.com/docs/en/essl/6.2?topic=representation-compressed-diagonal-storage-mode">IBM</a>) approach this, in standard DIAgonal format:</p>
<pre data-lang="py" style="background-color:#2b303b;color:#c0c5ce;" class="language-py "><code class="language-py" data-lang="py"><span>&gt;&gt;&gt; </span><span style="color:#b48ead;">from </span><span>scipy.sparse </span><span style="color:#b48ead;">import </span><span>dia_matrix
</span><span>&gt;&gt;&gt; data = np.</span><span style="color:#bf616a;">array</span><span>([[</span><span style="color:#d08770;">1</span><span>,</span><span style="color:#d08770;">0</span><span>,</span><span style="color:#d08770;">0</span><span>,</span><span style="color:#d08770;">5</span><span>], [</span><span style="color:#d08770;">0</span><span>,</span><span style="color:#d08770;">2</span><span>,</span><span style="color:#d08770;">0</span><span>,</span><span style="color:#d08770;">0</span><span>], [</span><span style="color:#d08770;">8</span><span>,</span><span style="color:#d08770;">0</span><span>,</span><span style="color:#d08770;">3</span><span>,</span><span style="color:#d08770;">0</span><span>], [</span><span style="color:#d08770;">6</span><span>,</span><span style="color:#d08770;">8</span><span>,</span><span style="color:#d08770;">0</span><span>,</span><span style="color:#d08770;">4</span><span>]])
</span><span>&gt;&gt;&gt; data
</span><span style="color:#bf616a;">array</span><span>([[</span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">5</span><span>],
</span><span>       [</span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">2</span><span>, </span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">0</span><span>],
</span><span>       [</span><span style="color:#d08770;">8</span><span>, </span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">3</span><span>, </span><span style="color:#d08770;">0</span><span>],
</span><span>       [</span><span style="color:#d08770;">6</span><span>, </span><span style="color:#d08770;">8</span><span>, </span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">4</span><span>]])
</span><span>&gt;&gt;&gt; m = </span><span style="color:#bf616a;">dia_matrix</span><span>(data)
</span><span>&gt;&gt;&gt; m
</span><span>&lt;4x4 sparse matrix of </span><span style="color:#96b5b4;">type </span><span>&#39;</span><span style="color:#a3be8c;">&lt;class </span><span>&#39;numpy.int64&#39;</span><span style="color:#a3be8c;">&gt;</span><span>&#39;
</span><span>	</span><span style="color:#b48ead;">with </span><span style="color:#d08770;">8 </span><span>stored </span><span style="color:#bf616a;">elements </span><span>(</span><span style="color:#d08770;">4 </span><span>diagonals) in DIAgonal </span><span style="color:#96b5b4;">format</span><span>&gt;
</span><span>&gt;&gt;&gt; m.data </span><span style="color:#65737e;"># ...usually labeled AD
</span><span style="color:#bf616a;">array</span><span>([[</span><span style="color:#d08770;">6</span><span>, </span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">0</span><span>],
</span><span>       [</span><span style="color:#d08770;">8</span><span>, </span><span style="color:#d08770;">8</span><span>, </span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">0</span><span>],
</span><span>       [</span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">2</span><span>, </span><span style="color:#d08770;">3</span><span>, </span><span style="color:#d08770;">4</span><span>],
</span><span>       [</span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">5</span><span>]])
</span><span>&gt;&gt;&gt; m.offsets </span><span style="color:#65737e;"># ...usually labeled LA
</span><span style="color:#bf616a;">array</span><span>([-</span><span style="color:#d08770;">3</span><span>, -</span><span style="color:#d08770;">2</span><span>,  </span><span style="color:#d08770;">0</span><span>,  </span><span style="color:#d08770;">3</span><span>], </span><span style="color:#bf616a;">dtype</span><span>=int32)
</span></code></pre>
<p>The offsets in this case refer to the diagonal index of each band. In this case, we have:</p>
<pre data-lang="py" style="background-color:#2b303b;color:#c0c5ce;" class="language-py "><code class="language-py" data-lang="py"><span style="color:#bf616a;">array</span><span>([[ </span><span style="color:#d08770;">0</span><span>,  </span><span style="color:#d08770;">1</span><span>,  </span><span style="color:#d08770;">2</span><span>, </span><span style="color:#d08770;">3</span><span>],
</span><span>       [-</span><span style="color:#d08770;">1</span><span>,  </span><span style="color:#d08770;">0</span><span>,  </span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">2</span><span>],
</span><span>       [-</span><span style="color:#d08770;">2</span><span>, -</span><span style="color:#d08770;">1</span><span>,  </span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">1</span><span>],
</span><span>       [-</span><span style="color:#d08770;">3</span><span>, -</span><span style="color:#d08770;">2</span><span>, -</span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">0</span><span>]])
</span></code></pre>
<p>Note however that this approach pads the bands with zeros. I’m not exactly sure why; perhaps to simplify
indexing or provide a standard matrix representation. However, this requires additional space that is effectively
wasted. What if, instead, we use a single dimension and provide offsets, i.e.,</p>
<pre data-lang="py" style="background-color:#2b303b;color:#c0c5ce;" class="language-py "><code class="language-py" data-lang="py"><span>&gt;&gt;&gt; </span><span style="color:#b48ead;">from </span><span>my_scipy.sparse </span><span style="color:#b48ead;">import </span><span>dia_matrix_v2
</span><span>&gt;&gt;&gt; data = np.</span><span style="color:#bf616a;">array</span><span>([[</span><span style="color:#d08770;">1</span><span>,</span><span style="color:#d08770;">0</span><span>,</span><span style="color:#d08770;">0</span><span>,</span><span style="color:#d08770;">5</span><span>], [</span><span style="color:#d08770;">0</span><span>,</span><span style="color:#d08770;">2</span><span>,</span><span style="color:#d08770;">0</span><span>,</span><span style="color:#d08770;">0</span><span>], [</span><span style="color:#d08770;">8</span><span>,</span><span style="color:#d08770;">0</span><span>,</span><span style="color:#d08770;">3</span><span>,</span><span style="color:#d08770;">0</span><span>], [</span><span style="color:#d08770;">6</span><span>,</span><span style="color:#d08770;">8</span><span>,</span><span style="color:#d08770;">0</span><span>,</span><span style="color:#d08770;">4</span><span>]])
</span><span>&gt;&gt;&gt; data
</span><span style="color:#bf616a;">array</span><span>([[</span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">5</span><span>],
</span><span>       [</span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">2</span><span>, </span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">0</span><span>],
</span><span>       [</span><span style="color:#d08770;">8</span><span>, </span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">3</span><span>, </span><span style="color:#d08770;">0</span><span>],
</span><span>       [</span><span style="color:#d08770;">6</span><span>, </span><span style="color:#d08770;">8</span><span>, </span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">4</span><span>]])
</span><span>&gt;&gt;&gt; m = </span><span style="color:#bf616a;">dia_matrix_v2</span><span>(data)
</span><span>&gt;&gt;&gt; m.data
</span><span style="color:#bf616a;">array</span><span>([</span><span style="color:#d08770;">6</span><span>, </span><span style="color:#d08770;">8</span><span>, </span><span style="color:#d08770;">8</span><span>, </span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">2</span><span>, </span><span style="color:#d08770;">3</span><span>, </span><span style="color:#d08770;">4</span><span>, </span><span style="color:#d08770;">5</span><span>])
</span><span>&gt;&gt;&gt; m.offsets
</span><span>{-</span><span style="color:#d08770;">3</span><span>: </span><span style="color:#d08770;">0</span><span>, -</span><span style="color:#d08770;">2</span><span>: </span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">0</span><span>: </span><span style="color:#d08770;">3</span><span>, </span><span style="color:#d08770;">3</span><span>: </span><span style="color:#d08770;">7</span><span>}
</span></code></pre>
<p>We’ve provided a mapping from its diagonal index to its offset in the data array.
Moreover, we can determine the end of the slice implicitly from the diagonal index.
Given an (N \times N) matrix and a diagonal index $d_i$, the length is $N - \text{abs}(d_i)$.
More generally, given a data array $AD$ and a offset mapping $LA$ for an $N \times N$ matrix, the diagonal at $d_i$ is bounded in $AD$ by:</p>
<p>$$
\Bigl[LA[d_i], LA[d_i] + N - \text{abs}(d_i)\Bigr)
$$</p>
<p>For example, in the array above, the diagonal at diagonal index 0 is bounded by:</p>
<p>$$
\Bigl[LA[d_i], LA[d_i] + N - \text{abs}(d_i)\Bigr)
= \Bigl[3, 3 + 4 - \text{abs}(0)\Bigr)
= \Bigl[3, 7\Bigr)
$$</p>
<p>Furthermore, this format is amenable to both <a rel="noopener nofollow noreferrer" target="_blank" href="https://en.wikipedia.org/wiki/Gather/scatter_(vector_addressing)">gather/scatter</a> and coiteration in <a rel="noopener nofollow noreferrer" target="_blank" href="https://fredrikbk.com/publications/kjolstad-thesis.pdf">sparse iteration theory</a>.
Given an index $(i, j)$ and a data array AD in row-major order, we can locate the respective value in compressed matrix $m$
using the formula:</p>
<p>$$
m(i,j) =
\begin{cases}
AD\Bigl( LA[j-i], i \Bigr) \text{ if } (j-i) \in LA \
0 \text { otherwise } \
\end{cases}
$$</p>
<p>The additional requirement for this format is a mapping from the diagonal index to the offset in the data array
and an additional lookup to find the offset. Nevertheless, we know ahead of time the size of this mapping is
bounded by $N * 2 - 1$ for an $N \times N$ diagonal, asymmetric matrix (and $N$ for a diagonal symmetric matrix).
As a result, this format can avoid redundant padding: concretely, we’ve halved the size of the data array in the
example above. More generally, the IBM/scipy.sparsepy format requires padding all diagonals to size N, which would
require space</p>
<p>$$
2N^2 - N
$$</p>
<p>in the worst case. The intuition behind this is there are $2N - 1$ diagonals in a $N \times N$ matrix, and each
requires $N$ space. Conversely, this new format only stores the immediate diagonal values, and requires space equivalent to</p>
<p>$$
N + 2 \sum_{i=1}^{N-1} i = N^2
$$</p>
<p>While only a constant factor improvement, this is still a non-trivial gain for extremely large diagonal matrices.
It also provides the same data locality benefits, i.e., all values in a diagonal are stored in contiguous memory and will in theory
lead to less cache misses since we don’t pad. Lastly, since a symmetric matrix is a special case of a diagonal matrix, the
same optimization can be applied to symmetric matrices.</p>

</div>


    </div>
  </section>

<footer>
  &copy;&nbsp;2023 Christophe Gyurgyik &middot; Built using <a href="https://www.getzola.org/">Zola</a> &middot; Adapted from <a href="https://www.rachitnigam.com/">Rachit Nigam</a>
</footer>

</body>

</html>
