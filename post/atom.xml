<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <title> - All Posts</title>
    <link rel="self" type="application/atom+xml" href="https://cgyurgyik.github.io/post/atom.xml"/>
    <link rel="alternate" type="text/html" href="https://cgyurgyik.github.io/post/"/>
    <generator uri="https://www.getzola.org/">Zola</generator>
    <updated>2025-12-23T00:00:00+00:00</updated>
    <id>https://cgyurgyik.github.io/post/atom.xml</id>
    <entry xml:lang="en">
        <title>Why scheduling languages exist</title>
        <published>2025-12-23T00:00:00+00:00</published>
        <updated>2025-12-23T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://cgyurgyik.github.io/post/scheduling-languages-exist/"/>
        <id>https://cgyurgyik.github.io/post/scheduling-languages-exist/</id>
        
        <content type="html" xml:base="https://cgyurgyik.github.io/post/scheduling-languages-exist/">&lt;p&gt;C.A.R. Hoare’s work &lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;10.5555&#x2F;63445.C1104369&quot;&gt;“Recursive data structures”&lt;&#x2F;a&gt; motivates a simple rule that good language design should abide by:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;(1) Implementation details that don’t affect program correctness should be syntactically &lt;em&gt;inexpressible&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;Codd’s &lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.seas.upenn.edu&#x2F;~zives&#x2F;03f&#x2F;cis550&#x2F;codd.pdf&quot;&gt;relational model&lt;&#x2F;a&gt; attempts to realize this: you declare &lt;em&gt;what&lt;&#x2F;em&gt; you want and the implementation is determined by the query optimizer. For example,&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sql&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sql &quot;&gt;&lt;code class=&quot;language-sql&quot; data-lang=&quot;sql&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;SELECT&lt;&#x2F;span&gt;&lt;span&gt; age &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;FROM&lt;&#x2F;span&gt;&lt;span&gt; users &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;WHERE&lt;&#x2F;span&gt;&lt;span&gt; age &amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;21
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The declarative language specifies nothing about index usage, join order, or memory allocation. In practice, relational database programmers still reason about implementation details, shaping queries to optimize well. Most programming languages abandon (1) entirely, giving us:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;(2) Implementation details that don’t affect program correctness are syntactically &lt;em&gt;expressible&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;Imperative languages like C are the obvious case, but even &lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;10.5555&#x2F;645420.652528&quot;&gt;Haskell qualifies&lt;&#x2F;a&gt;, where you make explicit decisions about memory representation:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;-- boxed (heap-allocated, thunk-able)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;foo &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;:: Int -&amp;gt; Int
&lt;&#x2F;span&gt;&lt;span&gt;foo x = x + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;-- unboxed (raw machine integer)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;foo &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;:: Int&lt;&#x2F;span&gt;&lt;span&gt;# &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;-&amp;gt; Int&lt;&#x2F;span&gt;&lt;span&gt;#
&lt;&#x2F;span&gt;&lt;span&gt;foo x = x +# &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;#
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Both snippets add &lt;code&gt;1&lt;&#x2F;code&gt; to the variable &lt;code&gt;x&lt;&#x2F;code&gt; with different data layouts. The choices are semantically invisible&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#1&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt; but syntactically different, and the latter exists solely for performance reasons. Scheduling languages like &lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;10.1145&#x2F;2491956.2462176&quot;&gt;Halide&lt;&#x2F;a&gt; and &lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;10.1145&#x2F;3133901&quot;&gt;TACO&lt;&#x2F;a&gt; take a different path:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;(3) Implementation details that don’t affect program correctness are confined to a separate language.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;In Halide, you write the algorithm once as a pure functional description, and then separately write a &lt;em&gt;schedule&lt;&#x2F;em&gt; specifying how the program should run. The schedule does not change the program semantics, only the execution strategy. This separation is enforced syntactically.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;cpp&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-cpp &quot;&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; algorithm
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;f&lt;&#x2F;span&gt;&lt;span&gt;(x) = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;a&lt;&#x2F;span&gt;&lt;span&gt;(x) * &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span&gt;(x);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; schedule
&lt;&#x2F;span&gt;&lt;span&gt;f.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;parallel&lt;&#x2F;span&gt;&lt;span&gt;(x);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The algorithm &lt;code&gt;f&lt;&#x2F;code&gt; is a simple element wise multiplication of two dense arrays &lt;code&gt;a&lt;&#x2F;code&gt; and &lt;code&gt;b&lt;&#x2F;code&gt;, and the schedule specifies that &lt;code&gt;f&lt;&#x2F;code&gt; should be run in parallel for all &lt;code&gt;x&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Why not just achieve (1) with a sufficiently clever compiler? Because determining which details “don’t affect correctness” requires deciding program equivalence (in general, &lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Rice%27s_theorem&quot;&gt;Rice’s theorem&lt;&#x2F;a&gt; forbids this). Languages abiding to (2) entangle performance control and algorithm semantics, and languages following (3) sidestep the problem by narrowing the domain to something tractable. Further, (3) doesn’t require the compiler to discover all semantics-preserving transformations&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#2&quot;&gt;2&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;, they provide a language for the programmer to express them, while &lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;10.1145&#x2F;3519939.3523446&quot;&gt;guaranteeing&lt;&#x2F;a&gt; that only semantics-preserving transformations are expressible.&lt;&#x2F;p&gt;
&lt;p&gt;So, why does (3) exist? (1) provides clarity but surrenders performance control, and (2) provides control at the cost of entanglement. Programmers in performance-critical domains want both semantic clarity and performance control. Scheduling languages deliver: reason about correctness in one language, optimize in another. This separation is &lt;em&gt;one&lt;&#x2F;em&gt; motivation for scheduling languages. There’s more to say (e.g., tractable search space, encapsulation benefits, ergonomic costs), but that’s for another post.&lt;&#x2F;p&gt;
&lt;p style=&quot;font-size:10px&quot;&gt;&lt;b&gt;Thank you to AJ Root and Rohan Yadav for their valuable feedback.&lt;&#x2F;b&gt;&lt;&#x2F;p&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;1&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2F;sup&gt;
&lt;p&gt;This is not true in general, the domain of unboxed types has no bottom element which just means they cannot be lazily evaluated. However, the point remains.&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;2&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;2&lt;&#x2F;sup&gt;
&lt;p&gt;Generally, scheduling languages also involve a compiler to realize some of the more “trivially” discoverable optimizations, e.g., constant folding or dead code elimination.&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
</content>
        
    </entry>
</feed>
